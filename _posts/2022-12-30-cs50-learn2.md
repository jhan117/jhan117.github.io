---
title: "CS: Data Structures"
categories:
  - "CS"
toc: true
toc_label: "CS50 6.자료구조"
toc_sticky: true
last_modified_at: 2022-12-30
---

## 학습 목표

- 배열의 크기 조정하기
- 연결 리스트: 도입
- 연결 리스트: 코딩
- 연결 리스트: 시연
- 연결 리스트: 트리
- 해시 테이블
- 트라이
- 스택, 큐, 딕셔너리

## 배열의 크기 조정하기

만약 배열의 크기를 키우고 싶다면 어떻게 해야 할까?

먼저 새로운 메모리를 할당하고 기존의 값을 전부 옮겨주는 방식이 있을 것이다. 이 작업은 O(n) 시간이 소요될 것이다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));

    // 포인터 잘 선언됐는지 확인
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // 새로운 메모리 할당
    int *tmp = malloc(4 * sizeof(int));

    if(tmp == NULL)
    {
        return 1;
    }

    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }

    tmp[3] = 4;

    free(list);

    list = tmp; // list가 tmp와 같은 곳을 가리키도록

    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i])
    }

    free(list);
}
```

위 과정을 쉽게 해주는 함수가 있다. 바로 `realloc`를 이용하면된다.

```c
int main(void)
{
    int *list = malloc(3 * sizeof(int));

    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    list = tmp;

    list[3] = 4;

    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    free(list);
}
```

## 연결 리스트: 도입

배열은 랜덤 접근이므로 인덱싱하기 쉽지만 새로운 값을 추가하기엔 O(n)의 시간이 걸린다는 단점이 있다. 이를 위해서 연결리스트 개념을 사용해볼 수 있는데 이는 메모리의 여러 군데에 값을 저장을 하고 그 메모리 주소만 기억하고 있다면 순차적 접근으로 인덱싱할 수 있다. 이는 새로운 값을 추가하기 쉽다는 장점을 가지고 있다.

![linked_list_with_addresses](https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png)

```c
// 구조체 안에서 node를 쓰기 위해 node를 함께 명시해준다.
typedef struct node
{
    int number;
    struct node *next;
}
node;
```

## 연결 리스트: 코딩

## 연결 리스트: 시연

## 연결 리스트: 트리

## 해시 테이블

## 트라이

## 스택, 큐, 딕셔너리

---

강의명

- 부스트코스 : 모두를 위한 컴퓨터 과학 (CS50 2019)
